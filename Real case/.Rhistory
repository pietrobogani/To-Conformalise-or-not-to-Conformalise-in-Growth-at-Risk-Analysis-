}
# Fit skewed-t distribution for quantile regression with NFCI and GDP, out-of-sample
qqTarg <- YQ_OOS[jt + h, ]
params <- QuantilesInterpolation_env$QuantilesInterpolation(qqTarg, QQ)
PST_OOS[jt + h, ] <- dst(YY, params$lc, params$sc, params$sh, params$df)
QST_OOS[jt + h, ] <- qst(QQ, params$lc, params$sc, params$sh, params$df)
CST_OOS[jt + h, ] <- pst(YY, params$lc, params$sc, params$sh, params$df)
STpar_OOS[jt + h, ] <- c(params$lc, params$sc, params$sh, params$df)
ScoreST_OOS[jt + h] <- dst(YhRealized, params$lc, params$sc, params$sh, params$df)
PitST_OOS[jt + h] <- pst(YhRealized, params$lc, params$sc, params$sh, params$df) # is the probability to observe a value < of YhRealized in this distribution
# Fit skewed-t distribution for quantile regression with GDP only, out-of-sample
qqTarg <- YQGDPonly_OOS[jt + h, ]
params_GDPonly <- QuantilesInterpolation_env$QuantilesInterpolation(qqTarg, QQ)
PSTGDPonly_OOS[jt + h, ] <- dst(YY, params_GDPonly$lc, params_GDPonly$sc, params_GDPonly$sh, params_GDPonly$df)
QSTGDPonly_OOS[jt + h, ] <- qst(QQ, params_GDPonly$lc, params_GDPonly$sc, params_GDPonly$sh, params_GDPonly$df)
CSTGDPonly_OOS[jt + h, ] <- pst(YY, params_GDPonly$lc, params_GDPonly$sc, params_GDPonly$sh, params_GDPonly$df)
STparGDPonly_OOS[jt + h, ] <- c(params_GDPonly$lc, params_GDPonly$sc, params_GDPonly$sh, params_GDPonly$df)
ScoreSTGDPonly_OOS[jt + h] <- dst(YhRealized, params_GDPonly$lc, params_GDPonly$sc, params_GDPonly$sh, params_GDPonly$df)
PitSTGDPonly_OOS[jt + h] <- pst(YhRealized, params_GDPonly$lc, params_GDPonly$sc, params_GDPonly$sh, params_GDPonly$df) # is the probability to observe a value < of YhRealized in this distribution
# Fit skewed t-distribution for unconditional quantiles, out-of-sample
qqTarg <- YQunc_OOS[jt + h, ]
params_unc <- QuantilesInterpolation_env$QuantilesInterpolation(qqTarg, QQ)
PSTunc_OOS[jt + h, ] <- dst(YY, params_unc$lc, params_unc$sc, params_unc$sh, params_unc$df)
QSTunc_OOS[jt + h, ] <- qst(QQ, params_unc$lc, params_unc$sc, params_unc$sh, params_unc$df)
CSTunc_OOS[jt + h, ] <- pst(YY, params_unc$lc, params_unc$sc, params_unc$sh, params_unc$df)
STparunc_OOS[jt + h, ] <- c(params_unc$lc, params_unc$sc, params_unc$sh, params_unc$df)
ScoreSTunc_OOS[jt + h] <- dst(YhRealized, params_unc$lc, params_unc$sc, params_unc$sh, params_unc$df)
PitSTunc_OOS[jt + h] <- pst(YhRealized, params_unc$lc, params_unc$sc, params_unc$sh, params_unc$df) # is the probability to observe a value < of YhRealized in this distribution
# Compute entropy for skewed t-distribution from quantile regression with GDP and NFCI, out-of-sample
Temp <- PST_OOS[jt + h, ] * (YY < QST_OOS[jt + h, jq50])
LeftEntropy_OOS[jt + h] <- -sum((log(PSTunc_OOS[jt + h, ]) - log(PST_OOS[jt + h, ])) * Temp * deltaYY)
}
}
}
qqTarg
# Set bounds for optimization
LB <- c(-20, 0, -30)
UB <- c(20, 50, 30)
lc0=NULL
sc0=NULL
sh0=NULL
# Locate target quantiles
jq50 <- which.min(abs(QQ - 0.50))
jq25 <- which.min(abs(QQ - 0.25))
jq75 <- which.min(abs(QQ - 0.75))
jq05 <- which.min(abs(QQ - 0.05))
jq95 <- which.min(abs(QQ - 0.95))
# Set initial conditions for optimization (if not provided)
if(is.null(lc0)) {
iqn <- qnorm(0.75) - qnorm(0.25)
lc0 <- qqTarg[jq50]
sc0 <- (qqTarg[jq75] - qqTarg[jq25]) / iqn
sh0 <- 0
}
Select <- c(jq05, jq25, jq75, jq95)
# Prepare for parallel execution
cl <- makeCluster(detectCores() - 1) # Use one less than the total number of cores
clusterExport(cl, c("qqTarg", "QQ", "qnorm", "nlminb", "qst","lc0","sc0", "sh0","jq05", "jq25", "jq75", "jq95"))
# Function to optimize in parallel for each degree of freedom
optimize_fn_nlminb <- function(df) {
objective_function <- function(p) {
sum((qqTarg[c(jq05, jq25, jq75, jq95)] - qst(QQ[c(jq05, jq25, jq75, jq95)], xi=p[1], omega=p[2], alpha=p[3], nu=df))^2)
}
result <- nlminb(start = c(lc0, sc0, sh0), objective_function, lower = c(-20, 0, -30), upper = c(20, 50, 30))
return(list(par = result$par, value = result$objective))
}
# Execute in parallel
results <- parLapply(cl, 1:30, optimize_fn_nlminb)
warnings()
# Install and load necessary packages
library(quantreg)
library(pracma)
library(readxl)
library(sn)
library(ggplot2)
library(quantreg)
library(dplyr)
# Clear workspace
rm(list = ls())
# Set forecast horizon (run script separately for h = 1 and h = 4)
h <- 4
loadsavedresults = FALSE; # If I have run code already and results are stored in ResOOS_H
par(mfrow = c(1, 1))  # Reset plot window to single pane
# Load data
file_path <- "DataVulnerabilityAppendix.xls"
# Read the file
data <- read_excel(file_path)
data<-data[,1:3]
# Filter data for 1973Q1-2015Q4
colnames(data)[1] <- "Time"
data$Time <- as.Date(data$Time)
# Subset the data
data <- data[data$Time >= as.Date("1973-01-01") & data$Time <= as.Date("2015-10-01"), ]
X <- data[,2:3]
Time <- data$Time
# Set forecast settings
QQ <- seq(0.05, 0.95, by = 0.05)
deltaYY <- 0.1
YY <- seq(-20, 20, by = deltaYY)
jtFirstOOS <- which(lubridate::year(data$Time) == 1993 & lubridate::month(data$Time) == 1)
indices <- which(QQ %in% c(0.05, 0.25, 0.5, 0.75, 0.95))
jq05 <- indices[1]
jq25 <- indices[2]
jq50 <- indices[3]
jq75 <- 15
jq95 <- 19
# Construct average growth rates
y <- X$A191RL1Q225SBEA
Yh <- matrix(0, nrow=length(y), ncol=4)
Yh <- stats::filter(y, rep(1/h, h), sides=1) #If h = 1, y = Yh
if (h>1){
Yh[1:(h-1)] <- NA
}
hist(y)
#Construct matrices of regressors
Z <- cbind(1, X[,2], y)
ZGDPonly <- cbind(1, y)
Z <-as.matrix(Z)
{
# Get length of Time and QQ/YY
len_time <- length(data$Time)
len_qq <- length(QQ)
len_yy <- length(YY)
# Initialize matrices to store forecasts
# Raw quantiles
YQ_NaNs <- matrix(NA, len_time, len_qq)
YQ_IS <- YQ_NaNs
YQ_OOS <- YQ_NaNs
YQGDPonly_IS <- YQ_NaNs
YQGDPonly_OOS <- YQ_NaNs
YQunc_IS <- YQ_NaNs
YQunc_OOS <- YQ_NaNs
# PDFs (evaluated over grid)
P_NaNs <- matrix(NA, len_time, len_yy)
PST_IS <- P_NaNs
PST_OOS <- P_NaNs
PSTGDPonly_IS <- P_NaNs
PSTGDPonly_OOS <- P_NaNs
PSTunc_IS <- P_NaNs
PSTunc_OOS <- P_NaNs
# Smoothed quantiles
Q_NaNs <- matrix(NA, len_time, len_qq)
QST_IS <- Q_NaNs
QST_OOS <- Q_NaNs
QSTGDPonly_IS <- Q_NaNs
QSTGDPonly_OOS <- Q_NaNs
QSTunc_IS <- Q_NaNs
QSTunc_OOS <- Q_NaNs
# CDFs (evaluated over grid)
C_NaNs <- matrix(NA, len_time, len_yy)
CST_IS <- C_NaNs
CST_OOS <- C_NaNs
CSTGDPonly_IS <- C_NaNs
CSTGDPonly_OOS <- C_NaNs
CSTunc_IS <- C_NaNs
CSTunc_OOS <- C_NaNs
# Skewed t-distribution parameters
STpar_NaNs <- matrix(NA, len_time, 4)
STpar_IS <- STpar_NaNs
STpar_OOS <- STpar_NaNs
STparGDPonly_IS <- STpar_NaNs
STparGDPonly_OOS <- STpar_NaNs
STparunc_IS <- STpar_NaNs
STparunc_OOS <- STpar_NaNs
# Predictive scores
Score_NaNs <- rep(NA, len_time)
ScoreST_IS <- Score_NaNs
ScoreST_OOS <- Score_NaNs
ScoreSTGDPonly_IS <- Score_NaNs
ScoreSTGDPonly_OOS <- Score_NaNs
ScoreSTunc_IS <- Score_NaNs
ScoreSTunc_OOS <- Score_NaNs
# Probability integral transforms
Pit_NaNs <- rep(NA, len_time)
PitST_IS <- Pit_NaNs
PitST_OOS <- Pit_NaNs
PitSTGDPonly_IS <- Pit_NaNs
PitSTGDPonly_OOS <- Pit_NaNs
PitSTunc_IS <- Pit_NaNs
PitSTunc_OOS <- Pit_NaNs
# Left entropy
Entropy_NaNs <- rep(NA, len_time)
LeftEntropy_IS <- Entropy_NaNs
LeftEntropy_OOS <- Entropy_NaNs
}
#---------    %% Fit skewed-t distribution for in-sample unconditional quantiles
# {
#
QuantilesInterpolation_env <- new.env()
source("QuantilesInterpolationfaster3.r",local = QuantilesInterpolation_env)
for (jt in 1:(length(Time) - h)) {
# month_val <- as.numeric(format(Time[jt], "%m"))
# year_val <- as.numeric(format(Time[jt], "%Y"))
#
# if (month_val == 1 && jt >= jtFirstOOS) {
#   cat(sprintf("Computing in-sample and out-of-sample predictive densities in %d", year_val), "\n")
# } else {
#   cat(sprintf("Computing in-sample predictive densities in %d", year_val), "\n")
# }
YhRealized <- Yh[jt + h]
#qqTarg <- YQ_IS[jt + h, ]
# params <- QuantilesInterpolation_env$QuantilesInterpolation(qqTarg, QQ)  # You might need to adjust this function to return params in appropriate format for dst, qst, pst
# lc <- params$lc
# sc <- params$sc
# sh <- params$sh
# df <- params$df
#
# PST_IS[jt + h, ] <- dst(YY, lc, sc, sh, df)
# QST_IS[jt + h, ] <- qst(QQ, lc, sc, sh, df)
# CST_IS[jt + h, ] <- pst(YY, lc, sc, sh, df)
# STpar_IS[jt + h, ] <- c(lc, sc, sh, df)
# ScoreST_IS[jt + h ] <- dst(YhRealized, lc, sc, sh, df)
# PitST_IS[jt + h ] <- pst(YhRealized, lc, sc, sh, df)    # is the probability to observe a value < of YhRealized in this distribution
#
# Temp <- PST_IS[jt + h, ] * (YY < QST_IS[jt + h, jq50])
# LeftEntropy_IS[jt + h] <- -sum((log(PSTunc_IS[jt + h, ]) - log(PST_IS[jt + h, ])) * Temp * deltaYY) #CORRETTO!
#
# Similar computations for GDP only
# qqTarg_GDPonly <- YQGDPonly_IS[jt + h, ]
#  params <- QuantilesInterpolation_env$QuantilesInterpolation(qqTarg_GDPonly, QQ)
#  lc <- params$lc
#  sc <- params$sc
#  sh <- params$sh
#  df <- params$df
# PSTGDPonly_IS[jt + h, ] <- dst(YY, lc, sc, sh, df)
# QSTGDPonly_IS[jt + h, ] <- qst(QQ, lc, sc, sh, df)
# CSTGDPonly_IS[jt + h, ] <- pst(YY, lc, sc, sh, df)
# STparGDPonly_IS[jt + h, ] <- c(lc, sc, sh, df)
# ScoreSTGDPonly_IS[jt + h] <- dst(YhRealized, lc, sc, sh, df)
# PitSTGDPonly_IS[jt + h] <- pst(YhRealized, lc, sc, sh, df) # is the probability to observe a value < of YhRealized in this distribution
#
if (jt >= jtFirstOOS) {
if (lubridate::month(Time[jt]) == 1) {
cat(sprintf("Now computing the real-time predictive densities in %d", lubridate::year(Time[jt])), "\n")
}
for (jq in 1:length(QQ)) {
# Quantile regression with both NFCI and GDP, out-of-sample
b <- rq(Yh[(h + 1):jt] ~ Z[1:(jt - h),-1], QQ[jq])
YQ_OOS[jt + h, jq] <- Z[jt, ] %*% coef(b)
# Quantile regression with GDP only, out-of-sample
bGDPonly <- rq(Yh[(h + 1):jt] ~ ZGDPonly[1:(jt- h),-1], tau=QQ[jq])
YQGDPonly_OOS[jt + h, jq] <- ZGDPonly[jt, ] %*% coef(bGDPonly)
# Unconditional quantiles, out-of-sample
bunc <- rq(Yh[(h + 1):jt ] ~ 1, QQ[jq])
YQunc_OOS[jt + h, jq] <- coef(bunc)
}
# Fit skewed-t distribution for quantile regression with NFCI and GDP, out-of-sample
qqTarg <- YQ_OOS[jt + h, ]
params <- QuantilesInterpolation_env$QuantilesInterpolation(qqTarg, QQ)
PST_OOS[jt + h, ] <- dst(YY, params$lc, params$sc, params$sh, params$df)
QST_OOS[jt + h, ] <- qst(QQ, params$lc, params$sc, params$sh, params$df)
CST_OOS[jt + h, ] <- pst(YY, params$lc, params$sc, params$sh, params$df)
STpar_OOS[jt + h, ] <- c(params$lc, params$sc, params$sh, params$df)
ScoreST_OOS[jt + h] <- dst(YhRealized, params$lc, params$sc, params$sh, params$df)
PitST_OOS[jt + h] <- pst(YhRealized, params$lc, params$sc, params$sh, params$df) # is the probability to observe a value < of YhRealized in this distribution
# Fit skewed-t distribution for quantile regression with GDP only, out-of-sample
qqTarg <- YQGDPonly_OOS[jt + h, ]
params_GDPonly <- QuantilesInterpolation_env$QuantilesInterpolation(qqTarg, QQ)
PSTGDPonly_OOS[jt + h, ] <- dst(YY, params_GDPonly$lc, params_GDPonly$sc, params_GDPonly$sh, params_GDPonly$df)
QSTGDPonly_OOS[jt + h, ] <- qst(QQ, params_GDPonly$lc, params_GDPonly$sc, params_GDPonly$sh, params_GDPonly$df)
CSTGDPonly_OOS[jt + h, ] <- pst(YY, params_GDPonly$lc, params_GDPonly$sc, params_GDPonly$sh, params_GDPonly$df)
STparGDPonly_OOS[jt + h, ] <- c(params_GDPonly$lc, params_GDPonly$sc, params_GDPonly$sh, params_GDPonly$df)
ScoreSTGDPonly_OOS[jt + h] <- dst(YhRealized, params_GDPonly$lc, params_GDPonly$sc, params_GDPonly$sh, params_GDPonly$df)
PitSTGDPonly_OOS[jt + h] <- pst(YhRealized, params_GDPonly$lc, params_GDPonly$sc, params_GDPonly$sh, params_GDPonly$df) # is the probability to observe a value < of YhRealized in this distribution
# Fit skewed t-distribution for unconditional quantiles, out-of-sample
qqTarg <- YQunc_OOS[jt + h, ]
params_unc <- QuantilesInterpolation_env$QuantilesInterpolation(qqTarg, QQ)
PSTunc_OOS[jt + h, ] <- dst(YY, params_unc$lc, params_unc$sc, params_unc$sh, params_unc$df)
QSTunc_OOS[jt + h, ] <- qst(QQ, params_unc$lc, params_unc$sc, params_unc$sh, params_unc$df)
CSTunc_OOS[jt + h, ] <- pst(YY, params_unc$lc, params_unc$sc, params_unc$sh, params_unc$df)
STparunc_OOS[jt + h, ] <- c(params_unc$lc, params_unc$sc, params_unc$sh, params_unc$df)
ScoreSTunc_OOS[jt + h] <- dst(YhRealized, params_unc$lc, params_unc$sc, params_unc$sh, params_unc$df)
PitSTunc_OOS[jt + h] <- pst(YhRealized, params_unc$lc, params_unc$sc, params_unc$sh, params_unc$df) # is the probability to observe a value < of YhRealized in this distribution
# Compute entropy for skewed t-distribution from quantile regression with GDP and NFCI, out-of-sample
Temp <- PST_OOS[jt + h, ] * (YY < QST_OOS[jt + h, jq50])
LeftEntropy_OOS[jt + h] <- -sum((log(PSTunc_OOS[jt + h, ]) - log(PST_OOS[jt + h, ])) * Temp * deltaYY)
}
}
# Install and load necessary packages
library(quantreg)
library(pracma)
library(readxl)
library(sn)
library(ggplot2)
library(quantreg)
library(dplyr)
# Clear workspace
rm(list = ls())
# Set forecast horizon (run script separately for h = 1 and h = 4)
h <- 4
loadsavedresults = FALSE; # If I have run code already and results are stored in ResOOS_H
par(mfrow = c(1, 1))  # Reset plot window to single pane
# Load data
file_path <- "DataVulnerabilityAppendix.xls"
# Read the file
data <- read_excel(file_path)
data<-data[,1:3]
# Filter data for 1973Q1-2015Q4
colnames(data)[1] <- "Time"
data$Time <- as.Date(data$Time)
# Subset the data
data <- data[data$Time >= as.Date("1973-01-01") & data$Time <= as.Date("2015-10-01"), ]
X <- data[,2:3]
Time <- data$Time
# Set forecast settings
QQ <- seq(0.05, 0.95, by = 0.05)
deltaYY <- 0.1
YY <- seq(-20, 20, by = deltaYY)
jtFirstOOS <- which(lubridate::year(data$Time) == 1993 & lubridate::month(data$Time) == 1)
indices <- which(QQ %in% c(0.05, 0.25, 0.5, 0.75, 0.95))
jq05 <- indices[1]
jq25 <- indices[2]
jq50 <- indices[3]
jq75 <- 15
jq95 <- 19
# Construct average growth rates
y <- X$A191RL1Q225SBEA
Yh <- matrix(0, nrow=length(y), ncol=4)
Yh <- stats::filter(y, rep(1/h, h), sides=1) #If h = 1, y = Yh
if (h>1){
Yh[1:(h-1)] <- NA
}
hist(y)
#Construct matrices of regressors
Z <- cbind(1, X[,2], y)
ZGDPonly <- cbind(1, y)
Z <-as.matrix(Z)
{
# Get length of Time and QQ/YY
len_time <- length(data$Time)
len_qq <- length(QQ)
len_yy <- length(YY)
# Initialize matrices to store forecasts
# Raw quantiles
YQ_NaNs <- matrix(NA, len_time, len_qq)
YQ_IS <- YQ_NaNs
YQ_OOS <- YQ_NaNs
YQGDPonly_IS <- YQ_NaNs
YQGDPonly_OOS <- YQ_NaNs
YQunc_IS <- YQ_NaNs
YQunc_OOS <- YQ_NaNs
# PDFs (evaluated over grid)
P_NaNs <- matrix(NA, len_time, len_yy)
PST_IS <- P_NaNs
PST_OOS <- P_NaNs
PSTGDPonly_IS <- P_NaNs
PSTGDPonly_OOS <- P_NaNs
PSTunc_IS <- P_NaNs
PSTunc_OOS <- P_NaNs
# Smoothed quantiles
Q_NaNs <- matrix(NA, len_time, len_qq)
QST_IS <- Q_NaNs
QST_OOS <- Q_NaNs
QSTGDPonly_IS <- Q_NaNs
QSTGDPonly_OOS <- Q_NaNs
QSTunc_IS <- Q_NaNs
QSTunc_OOS <- Q_NaNs
# CDFs (evaluated over grid)
C_NaNs <- matrix(NA, len_time, len_yy)
CST_IS <- C_NaNs
CST_OOS <- C_NaNs
CSTGDPonly_IS <- C_NaNs
CSTGDPonly_OOS <- C_NaNs
CSTunc_IS <- C_NaNs
CSTunc_OOS <- C_NaNs
# Skewed t-distribution parameters
STpar_NaNs <- matrix(NA, len_time, 4)
STpar_IS <- STpar_NaNs
STpar_OOS <- STpar_NaNs
STparGDPonly_IS <- STpar_NaNs
STparGDPonly_OOS <- STpar_NaNs
STparunc_IS <- STpar_NaNs
STparunc_OOS <- STpar_NaNs
# Predictive scores
Score_NaNs <- rep(NA, len_time)
ScoreST_IS <- Score_NaNs
ScoreST_OOS <- Score_NaNs
ScoreSTGDPonly_IS <- Score_NaNs
ScoreSTGDPonly_OOS <- Score_NaNs
ScoreSTunc_IS <- Score_NaNs
ScoreSTunc_OOS <- Score_NaNs
# Probability integral transforms
Pit_NaNs <- rep(NA, len_time)
PitST_IS <- Pit_NaNs
PitST_OOS <- Pit_NaNs
PitSTGDPonly_IS <- Pit_NaNs
PitSTGDPonly_OOS <- Pit_NaNs
PitSTunc_IS <- Pit_NaNs
PitSTunc_OOS <- Pit_NaNs
# Left entropy
Entropy_NaNs <- rep(NA, len_time)
LeftEntropy_IS <- Entropy_NaNs
LeftEntropy_OOS <- Entropy_NaNs
}
#---------    %% Fit skewed-t distribution for in-sample unconditional quantiles
# {
#
QuantilesInterpolation_env <- new.env()
source("QuantilesInterpolationfaster3.r",local = QuantilesInterpolation_env)
for (jt in 1:(length(Time) - h)) {
# month_val <- as.numeric(format(Time[jt], "%m"))
# year_val <- as.numeric(format(Time[jt], "%Y"))
#
# if (month_val == 1 && jt >= jtFirstOOS) {
#   cat(sprintf("Computing in-sample and out-of-sample predictive densities in %d", year_val), "\n")
# } else {
#   cat(sprintf("Computing in-sample predictive densities in %d", year_val), "\n")
# }
YhRealized <- Yh[jt + h]
#qqTarg <- YQ_IS[jt + h, ]
# params <- QuantilesInterpolation_env$QuantilesInterpolation(qqTarg, QQ)  # You might need to adjust this function to return params in appropriate format for dst, qst, pst
# lc <- params$lc
# sc <- params$sc
# sh <- params$sh
# df <- params$df
#
# PST_IS[jt + h, ] <- dst(YY, lc, sc, sh, df)
# QST_IS[jt + h, ] <- qst(QQ, lc, sc, sh, df)
# CST_IS[jt + h, ] <- pst(YY, lc, sc, sh, df)
# STpar_IS[jt + h, ] <- c(lc, sc, sh, df)
# ScoreST_IS[jt + h ] <- dst(YhRealized, lc, sc, sh, df)
# PitST_IS[jt + h ] <- pst(YhRealized, lc, sc, sh, df)    # is the probability to observe a value < of YhRealized in this distribution
#
# Temp <- PST_IS[jt + h, ] * (YY < QST_IS[jt + h, jq50])
# LeftEntropy_IS[jt + h] <- -sum((log(PSTunc_IS[jt + h, ]) - log(PST_IS[jt + h, ])) * Temp * deltaYY) #CORRETTO!
#
# Similar computations for GDP only
# qqTarg_GDPonly <- YQGDPonly_IS[jt + h, ]
#  params <- QuantilesInterpolation_env$QuantilesInterpolation(qqTarg_GDPonly, QQ)
#  lc <- params$lc
#  sc <- params$sc
#  sh <- params$sh
#  df <- params$df
# PSTGDPonly_IS[jt + h, ] <- dst(YY, lc, sc, sh, df)
# QSTGDPonly_IS[jt + h, ] <- qst(QQ, lc, sc, sh, df)
# CSTGDPonly_IS[jt + h, ] <- pst(YY, lc, sc, sh, df)
# STparGDPonly_IS[jt + h, ] <- c(lc, sc, sh, df)
# ScoreSTGDPonly_IS[jt + h] <- dst(YhRealized, lc, sc, sh, df)
# PitSTGDPonly_IS[jt + h] <- pst(YhRealized, lc, sc, sh, df) # is the probability to observe a value < of YhRealized in this distribution
#
if (jt >= jtFirstOOS) {
if (lubridate::month(Time[jt]) == 1) {
cat(sprintf("Now computing the real-time predictive densities in %d", lubridate::year(Time[jt])), "\n")
}
for (jq in 1:length(QQ)) {
# Quantile regression with both NFCI and GDP, out-of-sample
b <- rq(Yh[(h + 1):jt] ~ Z[1:(jt - h),-1], QQ[jq])
YQ_OOS[jt + h, jq] <- Z[jt, ] %*% coef(b)
# Quantile regression with GDP only, out-of-sample
bGDPonly <- rq(Yh[(h + 1):jt] ~ ZGDPonly[1:(jt- h),-1], tau=QQ[jq])
YQGDPonly_OOS[jt + h, jq] <- ZGDPonly[jt, ] %*% coef(bGDPonly)
# Unconditional quantiles, out-of-sample
bunc <- rq(Yh[(h + 1):jt ] ~ 1, QQ[jq])
YQunc_OOS[jt + h, jq] <- coef(bunc)
}
# Fit skewed-t distribution for quantile regression with NFCI and GDP, out-of-sample
qqTarg <- YQ_OOS[jt + h, ]
params <- QuantilesInterpolation_env$QuantilesInterpolation(qqTarg, QQ)
PST_OOS[jt + h, ] <- dst(YY, params$lc, params$sc, params$sh, params$df)
QST_OOS[jt + h, ] <- qst(QQ, params$lc, params$sc, params$sh, params$df)
CST_OOS[jt + h, ] <- pst(YY, params$lc, params$sc, params$sh, params$df)
STpar_OOS[jt + h, ] <- c(params$lc, params$sc, params$sh, params$df)
ScoreST_OOS[jt + h] <- dst(YhRealized, params$lc, params$sc, params$sh, params$df)
PitST_OOS[jt + h] <- pst(YhRealized, params$lc, params$sc, params$sh, params$df) # is the probability to observe a value < of YhRealized in this distribution
# Fit skewed-t distribution for quantile regression with GDP only, out-of-sample
qqTarg <- YQGDPonly_OOS[jt + h, ]
params_GDPonly <- QuantilesInterpolation_env$QuantilesInterpolation(qqTarg, QQ)
PSTGDPonly_OOS[jt + h, ] <- dst(YY, params_GDPonly$lc, params_GDPonly$sc, params_GDPonly$sh, params_GDPonly$df)
QSTGDPonly_OOS[jt + h, ] <- qst(QQ, params_GDPonly$lc, params_GDPonly$sc, params_GDPonly$sh, params_GDPonly$df)
CSTGDPonly_OOS[jt + h, ] <- pst(YY, params_GDPonly$lc, params_GDPonly$sc, params_GDPonly$sh, params_GDPonly$df)
STparGDPonly_OOS[jt + h, ] <- c(params_GDPonly$lc, params_GDPonly$sc, params_GDPonly$sh, params_GDPonly$df)
ScoreSTGDPonly_OOS[jt + h] <- dst(YhRealized, params_GDPonly$lc, params_GDPonly$sc, params_GDPonly$sh, params_GDPonly$df)
PitSTGDPonly_OOS[jt + h] <- pst(YhRealized, params_GDPonly$lc, params_GDPonly$sc, params_GDPonly$sh, params_GDPonly$df) # is the probability to observe a value < of YhRealized in this distribution
# Fit skewed t-distribution for unconditional quantiles, out-of-sample
qqTarg <- YQunc_OOS[jt + h, ]
params_unc <- QuantilesInterpolation_env$QuantilesInterpolation(qqTarg, QQ)
PSTunc_OOS[jt + h, ] <- dst(YY, params_unc$lc, params_unc$sc, params_unc$sh, params_unc$df)
QSTunc_OOS[jt + h, ] <- qst(QQ, params_unc$lc, params_unc$sc, params_unc$sh, params_unc$df)
CSTunc_OOS[jt + h, ] <- pst(YY, params_unc$lc, params_unc$sc, params_unc$sh, params_unc$df)
STparunc_OOS[jt + h, ] <- c(params_unc$lc, params_unc$sc, params_unc$sh, params_unc$df)
ScoreSTunc_OOS[jt + h] <- dst(YhRealized, params_unc$lc, params_unc$sc, params_unc$sh, params_unc$df)
PitSTunc_OOS[jt + h] <- pst(YhRealized, params_unc$lc, params_unc$sc, params_unc$sh, params_unc$df) # is the probability to observe a value < of YhRealized in this distribution
# Compute entropy for skewed t-distribution from quantile regression with GDP and NFCI, out-of-sample
Temp <- PST_OOS[jt + h, ] * (YY < QST_OOS[jt + h, jq50])
LeftEntropy_OOS[jt + h] <- -sum((log(PSTunc_OOS[jt + h, ]) - log(PST_OOS[jt + h, ])) * Temp * deltaYY)
}
}
# Set bounds for optimization
LB <- c(-20, 0, -30)
UB <- c(20, 50, 30)
# Locate target quantiles
jq50 <- which.min(abs(QQ - 0.50))
jq25 <- which.min(abs(QQ - 0.25))
jq75 <- which.min(abs(QQ - 0.75))
jq05 <- which.min(abs(QQ - 0.05))
jq95 <- which.min(abs(QQ - 0.95))
iqn <- qnorm(0.75) - qnorm(0.25)
lc0 <- qqTarg[jq50]
sc0 <- (qqTarg[jq75] - qqTarg[jq25]) / iqn
sh0 <- 0
Select <- c(jq05, jq25, jq75, jq95)
# Prepare for parallel execution
cl <- makeCluster(detectCores() - 1) # Use one less than the total number of cores
clusterExport(cl, c("qqTarg", "QQ", "qnorm", "nlminb", "qst","lc0","sc0", "sh0","jq05", "jq25", "jq75", "jq95"))
# Function to optimize in parallel for each degree of freedom
optimize_fn_nlminb <- function(df) {
objective_function <- function(p) {
sum((qqTarg[c(jq05, jq25, jq75, jq95)] - qst(QQ[c(jq05, jq25, jq75, jq95)], xi=p[1], omega=p[2], alpha=p[3], nu=df))^2)
}
result <- nlminb(start = c(lc0, sc0, sh0), objective_function, lower = c(-20, 0, -30), upper = c(20, 50, 30))
return(list(par = result$par, value = result$objective))
}
